#!/usr/bin/env python
import argparse
import json
import os.path
import sys
from pip._vendor.distlib.locators import JSONLocator, SimpleScrapingLocator
from pip._vendor.distlib.locators import normalize_name, parse_requirement
from pip._vendor.distlib.markers import interpret


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Resolve pypi sources.')
    parser.add_argument('packages', metavar='package', type=str, nargs='*',
                        help='package requirement specifiers')
    parser.add_argument('-r', '--requirement', metavar='file', type=str, nargs='*',
                        help='requirements file')
    parser.add_argument('-V', '--python', type=str, default='3.6',
                        help='Python version to resolve dependencies for.')
    parser.add_argument('--no-cache', action='store_true', default=False,
                        help='Disable the cache')
    parser.add_argument('-i', '--index-url', type=str, action='append',
                        help='URLs of python package indexes')

    args = parser.parse_args()
else:
    args = None


DEPCACHE_FILE = os.path.expanduser('~/.cache/pipenv/depcache-py{}.json'.format(args.python))
INDEX_FILE = os.path.expanduser('index-py{}.json'.format(args.python))
PIPENV_LOCKFILE = os.path.expanduser('Pipfile.lock')

if os.path.exists(INDEX_FILE):
    with open(INDEX_FILE, 'r') as fd:
        INDEX = json.load(fd)
else:
    INDEX = {}

CACHE = INDEX.setdefault('cache', {})

with open(DEPCACHE_FILE, 'r') as fd:
    DEPCACHE = json.load(fd).get('dependencies')

DEFAULT_LOCK = {'pip': {'version': '==9.0.1'}, 'setuptools': {'version': '==28.8.0'}, 'wheel': {'version': '==0.29.0'}}
with open(PIPENV_LOCKFILE, 'r') as fd:
    PIPENV_LOCK = json.load(fd).get('default')
    PIPENV_LOCK.update(DEFAULT_LOCK)


packages = args.packages or []
for file in args.requirement or []:
    with open(file, 'r') as fd:
        for line in fd.readlines():
            packages.append(line)


locators = []
for index_url in args.index_url or ['https://pypi.org/simple']:
    locators.append(SimpleScrapingLocator(index_url, scheme='legacy'))

for spec in packages:
    spec, _, expr = spec.strip().partition(';')
    if expr and all(map(interpret, expr.split(';'))):
        # eg. enum34==1.1.6; python_version == '2.7'
        continue

    if not args.no_cache:
        key, _, version = normalize_name(spec).partition('==')
        if not version:
            version = PIPENV_LOCK.get(key, {}).get('version', '').lstrip('==')
        data = CACHE.get(key, {}).get(version, {})
    else:
        data = {}

    dist = None
    if not data:
        for dist in (d for d in (l.locate(spec) for l in locators) if d):
            key = normalize_name(dist.key)
            data.update({'key': key, 'name': dist.name, 'version': dist.version})
            srcs = data.setdefault('srcs', [])
            for url, digest in dist.digests.items():
                hash_algo, hash = digest
                if not url.endswith('.whl') and hash_algo == 'sha256':
                    srcs.append({'url': url, hash_algo: hash})

        if dist is None:
            raise Exception('could not locate %s' % spec)

        deps = data.setdefault('deps', [])
        if dist.version in DEPCACHE.get(key, {}):
            specs = DEPCACHE[key][dist.version]
        elif key in ('pip', 'setuptools', 'wheel'):
            specs = []
        else:
            raise Exception('could not resolve dependencies for %s %s' % (key, dist.version))

        for spec in specs:
            spec, _, expr = spec.partition(';')
            if expr and all(map(interpret, expr.split(';'))):
                continue
            req = parse_requirement(normalize_name(spec))
            if req:
                version = PIPENV_LOCK[req.name]['version'].lstrip('==')
                deps.append({'key': req.name, 'version': version})
    if data:
        print(json.dumps(data))
    if dist:
        CACHE.setdefault(key, {})[dist.version] = data

with open(INDEX_FILE, 'w') as fd:
    json.dump(INDEX, fd)

# vim:set ft=python:
